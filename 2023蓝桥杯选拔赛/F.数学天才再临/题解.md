# 数学天才再临题解

题意：在 $[1,m]$ 的范围内等概率地取 $n$ 个正整数，求 $n$ 个正整数两两互质的方案数。

（比赛无聊的时候，看了题面里链接的视频了吗，非常有意思，强烈推荐！）

### $m=1$ 解法

当 $m=1$ 时只有一种填法：每一位都填 $1$，必然满足两两互质，因此直接输出 $1$ 可以得到 $m=1$ 的分数。

### $m=2$ 解法

当 $m=2$ 时，其中一种填法是所有位都填 $1$，另一种是从 $n$ 位中选择一个填 $2$（共 $n$ 个可选位置），因此当 $m=2$ 时可以直接输出 $n+1$。

### $n=2$ 解法

$n=2$ 时两个 `for` 循环 $O(n^2)$ 从 $1$ 到 $m$ 枚举两个数字，当最大公约数为 $1$ 时加到答案上，核心代码如下：

```c
int gcd(int a, int b) {
    return b == 0? a: gcd(b, a % b);
}

for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (gcd(i, j) == 1) {
            ++ans;
        }
    }
}
```

### $3\leq n\leq5$ 解法

从 $1$ 到 $n$ 每一位都枚举 $1$ 到 $m$，枚举到第 $i$ 个数字时判断是否与前 $i-1$ 个数字都互质，若都互质则填入，继续枚举第 $i+1$ 个数字。

由于循环层数 $n$ 非固定值，可用递归实现暴力搜索，不会写递归可以通过对 $n$ 值的特判写几个分支，分别对应不同层数的 `for` 循环，时间复杂度 $O(m^n)$，核心代码如下：

```c
int gcd(int a, int b) {
    return b == 0? a: gcd(b, a % b);
}

void dfs(int depth) {
    if (depth == n + 1) {
        ++ans;
        return ;
    }
    for (int i = 1; i <= m; ++i) {
        bool flag = true;
        for (int j = 1; j < depth; ++j) {
            if (gcd(i, num[j]) != 1) {
                flag = false;
                break;
            }
        }
        if (flag) {
            num[depth] = i;
            dfs(depth + 1);
        }
    }
}
```

### $n\in[3,1000],~m\in[1,30]$ 解法

换一种角度考虑”互质“：一个整数可以分解成多个质因数幂次相乘的形式，当两个整数的质因数没有交集时，这两个数字互质。

用二进制位表示质因数集合，第 $0$ 位为 $1$ 表示包含第 $1$ 个质数 $2$，第 $1$ 位为 $1$ 表示包含第二个质数 $3$，以此类推。

定义状态 $dp(i,j)$ 表示前 $i$ 个已填数字的质因数集合的二进制表示为 $j$，有如下递推式：

$$
dp(i,j)=\sum_{k=1}^mdp(i-1,j~\text{xor}~bit(k))\quad (bit(k)~\text{and}~j=bit(k))
$$

其中，$\text{xor}$ 表示按位异或，$\text{and}$ 表示按位与， $bit(k)$ 表示整数 $k$ 的质因数集合的二进制位表示，如 $bit(20)=bit(2^2\times5)=(101)_{2}=(5)_{10}$，上式在 $k$ 的质因数集合为 $j$ 所代表集合的子集时（即满足条件 $bit(k)~\text{and}~j=bit(k)$）可以转移。

递推式含义为：前 $i$ 位质因数状态为 $j$ 的方案数，等于往第 $i$ 位填数字 $k~(k\in[1,m])$ 的方案数总和，当第 $i$ 位填入 $k$ 时，前 $i-1$ 位的质因数状态只能为 $j~\text{xor}~bit(k)$ 才能保证前 $i$ 位整数两两互质。初始值为 $dp(0,0)=1$，答案为 $\sum_{j=0}^{2^{cnt}-1} dp(n,j)$，$cnt$ 为小于等于 $m$ 的质数个数。

时间复杂度：递推式时间复杂度为 $O(nm\times2^{\frac{m}{\ln m}})$，$30$ 以内有 $10$ 个质数，最坏情况下计算次数为 $1000\times30\times2^{10}\approx3\times10^7$，可以通过这部分数据，$m=60$ 时最坏情况计算次数为 $1000\times60\times2^{17}\approx7.8\times10^9$，超过 $10^8$ 会导致超时。

代码如下：

```c
#include <stdio.h>

typedef long long LL;
const LL MOD = 1000000007;
const int maxP = 17;
int n, m;
LL ans;
int bit[61];
LL dp[1001][1 << 17];
int prime[17] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 , 59};

int main() {
    scanf("%d%d", &n, &m);

    // bit 预处理
    for (int i = 1; i <= m; ++i) {
        for (int j = 0; j < maxP; ++j) {
            if (i % prime[j] == 0) {
                bit[i] |= (1 << j);
            }
        }
    }

    // 找出需要遍历多少个质数，确定集合大小
    int cnt = 0;
    for (int i = 0; i < maxP; ++i) {
        if (prime[i] <= m) {
            ++cnt;
        }
    }

    // dp 转移
    dp[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < (1 << cnt); ++j) {
            for (int k = 1; k <= m; ++k) {
                if ((j & bit[k]) == bit[k]) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j ^ bit[k]]) % MOD;
                }
            }
        }
    }
    for (int i = 0; i < (1 << cnt); ++i) {
        ans = (ans + dp[n][i]) % MOD;
    }
    printf("%lld\n", ans);

    return 0;
}
```

### 满分解法

继续观察发现，当我们找到一组不等于 $1$ 的由 $i$ 个数字组成的互质组合时（如 $3, 7, 10$），我们有 $\text{C}_n^i$ 种方式把它放到一个长度为 $n$ 的数组，其他 $n-i$ 位可以全填 $1$，发现这里面的方案数计算时间复杂度与 $n$ 无关（$\text{C}_n^i$ 可以 $O(n^2)$ 预处理，$O(1)$ 读取）。

因此我们可以定义状态 $dp(i,j)$ 表示由 $i$ 个**不包含 $1$ 的**已填数字的质因数集合的二进制表示为 $j$，有如下递推式：

$$
dp(i,j)=\sum_{k=2}^mdp(i-1,j~\text{xor}~bit(k))\quad (bit(k)~\text{and}~j=bit(k))
$$

递推式与上一种解法类似，但 $k$ 从 $2$ 开始，且 $i$ 最大为 $\min(cnt, n)$，最终答案等于：

$$
ans=\sum_{i=0}^{\min(cnt, n)}\sum_{j=0}^{2^{cnt}-1}dp(i,j)\times C_n^i
$$

其中 $cnt$ 为小于等于 $m$ 的质数的个数，表示最多只需要 $cnt$ 位就能枚举尽所有方案，初始状态 $dp(0,0)=1$。

时间复杂度：$O(\frac{m}{\ln m}\times2^{\frac{m}{\ln m}}\times m+n^2)$，其中 $n^2$ 为预处理 $C_n^k$ 的时间复杂度，当 $n=1000,~m=60$ 时，最多需要执行 $17\times2^{17}\times60\approx1.8\times10^8$，加上一些小优化（见代码）可通过本题 100% 数据。

AC 代码示例：

```c
#include <stdio.h>

typedef long long LL;
const LL MOD = 1000000007;
const int maxP = 17;
int n, m;
LL ans;
int bit[61];
LL C[1001][1001];
LL dp[61][1 << 17];
int prime[17] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 , 59};

int main() {
    scanf("%d%d", &n, &m);

    // bit 预处理
    for (int i = 1; i <= m; ++i) {
        for (int j = 0; j < maxP; ++j) {
            if (i % prime[j] == 0) {
                bit[i] |= (1 << j);
            }
        }
    }
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (j == 0 || j == i) {
                C[i][j] = 1;
            } else {
                C[i][j] = (C[i - 1][j - 1] + C[i -  1][j]) % MOD;
            }
        }
    }

    // 找出需要遍历多少个质数，确定集合大小
    int cnt = 0;
    for (int i = 0; i < maxP; ++i) {
        if (prime[i] <= m) {
            ++cnt;
        }
    }

    // dp 转移
    dp[0][0] = 1;
    int mn = cnt < n ? cnt : n;
    for (int i = 0; i <= mn; ++i) {
        LL tmp = 0;
        for (int j = 0; j < (1 << cnt); ++j) {
            if (dp[i][j] == 0) {    // 减少状态转移次数的小优化
                continue;
            }
            for (int k = 2; k <= m; ++k) {
                if ((j & bit[k]) == 0) {
                    dp[i + 1][j | bit[k]] = (dp[i + 1][j | bit[k]] + dp[i][j]) % MOD;
                }
            }
            tmp = (tmp + dp[i][j]) % MOD;
        }
        ans = (ans + tmp * C[n][i] % MOD) % MOD;
    }
    printf("%lld\n", ans);

    return 0;
}
```

### 附加题

1. 若 $n=2,~m=100000$，如何求解？（提示：欧拉函数）
2. 若 $n=1000,~m=100$，如何求解？（提示：质数的性质）

### 数据生成

随机数据生成代码如下，其中 `std.exe` 为标程 `exe` 文件

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int testCases = 100;
ofstream fout;
int n, m;

string numToStr(int x) {
    string str;
    while (x != 0) {
        str = char('0' + x % 10) + str;
        x /= 10;
    }
    return str;
}

string getFileInName(int index) {
    return "data/" + numToStr(index) + ".in";
}

string getFileOutName(int index) {
    return "data/" + numToStr(index) + ".out";
}

int getRand(int l, int r) {
    return (LL)rand() * rand() * rand() % (r - l + 1) + l;
}

void writeToFile(int from, int to, int l1, int r1, int l2, int r2) {
    for (int i = from; i <= to; ++i) {
        string fileInName = getFileInName(i);
        fout.open(fileInName);
        n = getRand(l1, r1);
        m = getRand(l2, r2);
        fout << n << " " << m << endl;
        fout.close();
        string fileOutName = getFileOutName(i);
        system(("std.exe < " + fileInName  + " > " + fileOutName).c_str());
    }
}

int main() {
    srand(time(0));

    // data in 5%, 2 <= n = 1000, m = 1
    int one = testCases * 5 / 100;
    writeToFile(1, one, 900, 1000, 1, 1);

    // data in 15%, 2 <= n <= 1000, m = 2
    int two = testCases * 15 / 100;
    writeToFile(one + 1, two, 900, 1000, 2, 2);

    // data in 25%, n = 2, 1 <= m <= 30
    int three = testCases * 25 / 100;
    writeToFile(two + 1, three, 2, 2, 25, 30);

    // data in 45%, 3 <= n <= 5, 1 <= m <= 30
    int four = testCases * 45 / 100;
    writeToFile(three + 1, four, 3, 5, 25, 30);

    // data in 75%, 3 <= n <= 1000, 1 <= m <= 30
    int five = testCases * 75 / 100;
    writeToFile(four + 1, five, 900, 1000, 25, 30);

    // data in 100%, 3 <= n <= 1000, 1 <= m <= 60
    writeToFile(five + 1, testCases, 900, 1000, 53, 60);

    return 0;
}
```

