# 数学天才再临题解

（比赛无聊的时候，看了题面里链接的视频了吗，非常有意思，强烈推荐！）

## 第一个 5% 解法

$n=2$ 时两个 `for` 循环 $O(n^2)$ 从 $1$ 到 $m$ 枚举两个数字，当最大公约数为 $1$ 时加到答案上，核心代码如下：

```c
int gcd(int a, int b) {
    return b == 0? a: gcd(b, a % b);
}

for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= m; ++j) {
        if (gcd(i, j) == 1) {
            ++ans;
        }
    }
}
```

## 第二个 5% 解法

当 $m=1$ 时只有一种填法：每一位都填 $1$，必然满足两两互质，因此直接输出 $1$ 可以得到第二个 5% 的分数。

## 第三个 5% 解法

当 $m=2$ 时，其中一种填法是所有位都填 $1$，另一种是从 $n$ 位中选择一个填 $2$（共 $n$ 个可选位置），因此当 $m=2$ 时可以直接输出 $n+1$。

## 前 25% 解法

从 $1$ 到 $n$ 每一位都枚举 $1$ 到 $m$，枚举到第 $i$ 个数字时判断是否与前 $i-1$ 个数字都互质，若都互质则填入，继续枚举第 $$i+1$ 个数字，核心代码如下：

```c
int gcd(int a, int b) {
    return b == 0? a: gcd(b, a % b);
}

void dfs(int i) {
    if (i == n + 1) {
        ++ans;
        return ;
    }
    for (int j = 1; j <= m; ++j) {
        bool flag = true;
        for (int k = 1; k < i; ++k) {
            if (gcd(j, num[k]) != 1) {
                flag = false;
                break;
            }
        }
        if (flag) {
            num[i] = j;
            dfs(i + 1);
        }
    }
}
```

## 前 55% 分数解法

换一种角度考虑”互质“：一个整数可以分解成多个质因数幂次相乘的形式，当两个整数的质因数没有交集时，这两个数字互质。

用二进制位表示质因数集合，第 $0$ 位为 $1$ 表示包含第 $1$ 个质数 $2$，第 $1$ 位为 $1$ 表示包含第二个质数 $3$，以此类推。

定义状态 `dp[i][j]` 表示前 $i$ 个已填数字的质因数集合的二进制表示为 $j$，有如下递推式：
$$
dp(i,j)=\sum_{k=1}^mdp(i-1,j~\text{xor}~bit(k))\quad (bit(k)~\text{and}~j=bit(k))
$$
其中，$\text{xor}$ 表示按位异或，$\text{and}$ 表示按位与， $bit(k)$ 表示整数 $k$ 的质因数集合的二进制位表示，如 $bit(20)=bit(2^2\times5)=(101)_{2}=(5)_{10}$，上式在 $k$ 的质因数集合为 $j$ 所代表集合的子集时（即满足条件 $bit(k)~\text{and}~j=bit(k)$）可以转移。

递推式含义为：前 $i$ 位质因数状态为 $j$ 的方案数，等于往第 $i$ 位填数字 $k~(k\in[1,m])$ 的方案数总和，当第 $i$ 位填入 $k$ 时，前 $i-1$ 位的质因数状态只能为 $j~\text{xor}~bit(k)$ 才能保证前 $i$ 位整数两两互质。初始值为 $dp(0,0)=1$，答案为 `dp[n]` 所有状态方案数总和。

递推式时间复杂度为 $O(nm\times2^{\frac{m}{\ln m}})$，$30$ 以内有 $10$ 个质数，最坏情况下计算次数为 $1000\times30\times2^{10}\approx3\times10^7$，可以通过前 55% 的数据，$m=50$ 时最坏情况计算次数为 $1000\times50\times2^{15}\approx1.6\times10^9$。

55% 分数代码如下：

```c

```

## 数据生成

随机数据生成代码如下，其中 `std.exe` 为标程 `exe` 文件

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int testCases = 50;
ofstream fout;

string numToStr(int x) {
    string str;
    while (x != 0) {
        str = char('0' + x % 10) + str;
        x /= 10;
    }
    return str;
}

string getFileInName(int index) {
    return "data/" + numToStr(index) + ".in";
}

string getFileOutName(int index) {
    return "data/" + numToStr(index) + ".out";
}

LL getRand(LL l, LL r) {
    return (LL)rand() * rand() * rand() % (r - l + 1) + l;
}

void writeToFile(int fileIdx, LL l, LL r) {
    string fileInName = getFileInName(fileIdx);
    fout.open(fileInName);
    LL e5 = 1e5;
    int T = getRand(90, 100);
    int idx = getRand(1, T);
    fout << T << endl;
    for (int i = 1; i <= T; ++i) {
        int a = 0;
        if (idx != i) {
            a = getRand(1, e5);
        }
        LL n = getRand(l, r);
        fout << a << " " << n << endl;
    }
    fout.close();
    string fileOutName = getFileOutName(fileIdx);
    system(("std.exe < " + fileInName  + " > " + fileOutName).c_str());
}

int main() {
    srand(time(0));

    LL e5 = 1e5;
    LL e10 = 1e10;
    LL e11 = 1e11;

    for (int i = 1; i <= testCases; ++i) {
        if (i % 2 == 0) {
            writeToFile(i, 1, e5);
        } else {
            writeToFile(i, e10, e11);
        }
    }

    return 0;
}
```

